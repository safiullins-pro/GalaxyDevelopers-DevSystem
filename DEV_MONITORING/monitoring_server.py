#!/usr/bin/env python3
"""
GALAXY MONITORING SERVER
–ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å WebSocket –∏ REST API
"""

import asyncio
import json
import os
import sys
import time
import ast
import subprocess
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional
import hashlib

# –í–µ–±-—Å–µ—Ä–≤–µ—Ä –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
from aiohttp import web
import aiohttp_cors
import websockets
from websockets.server import WebSocketServerProtocol

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# –ê–Ω–∞–ª–∏–∑ –∫–æ–¥–∞ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å
import pylint.lint
from pylint.reporters.json_reporter import JSONReporter
import bandit
from bandit.core import manager

# –ú–µ—Ç—Ä–∏–∫–∏
from prometheus_client import Counter, Gauge, Histogram, generate_latest
import logging
import sqlite3
from concurrent.futures import ThreadPoolExecutor

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ memory API
sys.path.append(str(Path(__file__).parent / 'memory'))

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('GalaxyMonitoring')

# Prometheus –º–µ—Ç—Ä–∏–∫–∏
file_changes_counter = Counter('galaxy_file_changes_total', 'Total number of file changes', ['type'])
syntax_errors_gauge = Gauge('galaxy_syntax_errors', 'Current number of syntax errors')
security_issues_gauge = Gauge('galaxy_security_issues', 'Current number of security issues')
compliance_score_gauge = Gauge('galaxy_compliance_score', 'Compliance score percentage', ['standard'])
websocket_connections_gauge = Gauge('galaxy_websocket_connections', 'Active WebSocket connections')
api_requests_counter = Counter('galaxy_api_requests_total', 'Total API requests', ['endpoint', 'method'])
check_duration_histogram = Histogram('galaxy_check_duration_seconds', 'Duration of checks', ['check_type'])

class FileChangeHandler(FileSystemEventHandler):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ñ–∞–π–ª–æ–≤"""
    
    def __init__(self, monitoring_server):
        self.monitoring_server = monitoring_server
        self.ignored_patterns = [
            '.DS_Store', '.git', '__pycache__', '*.pyc', 
            'node_modules', '*.swp', '*.tmp', '.venv', 'venv'
        ]
    
    def should_ignore(self, path: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω—É–∂–Ω–æ –ª–∏ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª"""
        path_str = str(path)
        return any(pattern in path_str for pattern in self.ignored_patterns)
    
    def on_modified(self, event):
        if not event.is_directory and not self.should_ignore(event.src_path):
            self.process_change(event.src_path, 'modified')
    
    def on_created(self, event):
        if not event.is_directory and not self.should_ignore(event.src_path):
            self.process_change(event.src_path, 'created')
    
    def on_deleted(self, event):
        if not event.is_directory and not self.should_ignore(event.src_path):
            self.process_change(event.src_path, 'deleted')
    
    def process_change(self, path: str, change_type: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞"""
        file_changes_counter.labels(type=change_type).inc()
        
        change_data = {
            'type': 'file_change',
            'change': {
                'path': path,
                'type': change_type,
                'timestamp': datetime.now().isoformat()
            }
        }
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å –∏–∑–º–µ–Ω–µ–Ω–∏–π
        self.monitoring_server.file_changes.append(change_data['change'])
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º WebSocket –∫–ª–∏–µ–Ω—Ç–∞–º
        asyncio.create_task(
            self.monitoring_server.broadcast_to_websockets(change_data)
        )
        
        logger.info(f"File {change_type}: {path}")


class MonitoringServer:
    """–û—Å–Ω–æ–≤–Ω–æ–π —Å–µ—Ä–≤–µ—Ä –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
    
    def __init__(self):
        self.websocket_clients = set()
        self.file_changes = []
        self.file_observer = None
        self.watch_paths = [
            '/Volumes/Z7S/development/GalaxyDevelopers/DevSystem/',
            '/Volumes/Z7S/development/ALBERT_TOOLS_PLACE/DocumentsSystem/',
            '/Users/safiullins_pro/Documents/'
        ]
        self.executor = ThreadPoolExecutor(max_workers=4)
        self.compliance_standards = {
            'ISO27001': self.check_iso27001_compliance,
            'ITIL4': self.check_itil4_compliance,
            'COBIT': self.check_cobit_compliance
        }
        self.agent_statuses = {}
        self.memory_db_path = Path(__file__).parent / 'memory' / 'unified_memory.db'
    
    async def start(self):
        """–ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–µ—Ä–≤–µ—Ä–∞"""
        logger.info("üöÄ Starting Galaxy Monitoring Server...")
        
        # –ó–∞–ø—É—Å–∫ —Ñ–∞–π–ª–æ–≤–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
        self.start_file_monitoring()
        
        # –ó–∞–ø—É—Å–∫ WebSocket —Å–µ—Ä–≤–µ—Ä–∞
        websocket_task = asyncio.create_task(self.start_websocket_server())
        
        # –ó–∞–ø—É—Å–∫ REST API —Å–µ—Ä–≤–µ—Ä–∞
        api_task = asyncio.create_task(self.start_api_server())
        
        # –ó–∞–ø—É—Å–∫ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
        periodic_task = asyncio.create_task(self.run_periodic_checks())
        
        await asyncio.gather(websocket_task, api_task, periodic_task)
    
    def start_file_monitoring(self):
        """–ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã"""
        try:
            self.file_observer = Observer()
            event_handler = FileChangeHandler(self)
            
            for path in self.watch_paths:
                if Path(path).exists():
                    self.file_observer.schedule(event_handler, path, recursive=True)
                    logger.info(f"üìÅ Watching: {path}")
                else:
                    logger.warning(f"Path does not exist: {path}")
            
            self.file_observer.start()
            logger.info("‚úÖ File monitoring started successfully")
        except Exception as e:
            logger.error(f"Failed to start file monitoring: {e}")
            self.file_observer = None
    
    async def start_websocket_server(self):
        """–ó–∞–ø—É—Å–∫ WebSocket —Å–µ—Ä–≤–µ—Ä–∞"""
        async def handle_websocket(websocket, path):
            self.websocket_clients.add(websocket)
            websocket_connections_gauge.inc()
            
            try:
                logger.info(f"‚úÖ WebSocket client connected from {websocket.remote_address}")
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ
                await websocket.send(json.dumps({
                    'type': 'connected',
                    'message': 'Galaxy Monitoring connected'
                }))
                
                # –î–µ—Ä–∂–∏–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç—ã–º
                while True:
                    try:
                        message = await asyncio.wait_for(websocket.recv(), timeout=30)
                        data = json.loads(message)
                        await self.handle_websocket_message(websocket, data)
                    except asyncio.TimeoutError:
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º ping –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                        await websocket.ping()
                    except websockets.exceptions.ConnectionClosed:
                        break
                    except Exception as e:
                        logger.error(f"WebSocket message error: {e}")
                        
            except Exception as e:
                logger.error(f"WebSocket error: {e}")
            finally:
                if websocket in self.websocket_clients:
                    self.websocket_clients.remove(websocket)
                    websocket_connections_gauge.dec()
                logger.info(f"üîå WebSocket client disconnected")
        
        server = await websockets.serve(handle_websocket, 'localhost', 8765)
        logger.info("üì° WebSocket server running on ws://localhost:8765")
        await asyncio.Future()  # Run forever
    
    async def start_api_server(self):
        """–ó–∞–ø—É—Å–∫ REST API —Å–µ—Ä–≤–µ—Ä–∞"""
        app = web.Application()
        
        # CORS –Ω–∞—Å—Ç—Ä–æ–π–∫–∞
        cors = aiohttp_cors.setup(app, defaults={
            "*": aiohttp_cors.ResourceOptions(
                allow_credentials=True,
                expose_headers="*",
                allow_headers="*",
                allow_methods="*"
            )
        })
        
        # –†–æ—É—Ç—ã
        app.router.add_get('/api/monitoring/file-changes', self.handle_file_changes)
        app.router.add_get('/api/monitoring/syntax-check', self.handle_syntax_check)
        app.router.add_get('/api/monitoring/security-scan', self.handle_security_scan)
        app.router.add_get('/api/monitoring/compliance/{standard}', self.handle_compliance_check)
        app.router.add_get('/api/monitoring/integration-test', self.handle_integration_test)
        app.router.add_post('/api/monitoring/start-watcher', self.handle_start_watcher)
        app.router.add_get('/api/monitoring/status', self.handle_status)
        app.router.add_get('/api/monitoring/metrics', self.handle_metrics)
        app.router.add_post('/api/agents/validate', self.handle_agent_validate)
        app.router.add_post('/api/agents/process', self.handle_agent_process)
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º CORS –∫–æ –≤—Å–µ–º —Ä–æ—É—Ç–∞–º
        for route in list(app.router._resources):
            cors.add(route)
        
        runner = web.AppRunner(app)
        await runner.setup()
        site = web.TCPSite(runner, 'localhost', 8766)
        await site.start()
        
        logger.info("üåê REST API server running on http://localhost:8766")
        await asyncio.Future()  # Run forever
    
    async def broadcast_to_websockets(self, data: dict):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤—Å–µ–º WebSocket –∫–ª–∏–µ–Ω—Ç–∞–º"""
        if self.websocket_clients:
            message = json.dumps(data)
            disconnected = set()
            
            for client in self.websocket_clients:
                try:
                    await client.send(message)
                except websockets.exceptions.ConnectionClosed:
                    disconnected.add(client)
            
            # –£–¥–∞–ª—è–µ–º –æ—Ç–∫–ª—é—á–µ–Ω–Ω—ã–µ –∫–ª–∏–µ–Ω—Ç—ã
            self.websocket_clients -= disconnected
    
    async def handle_websocket_message(self, websocket: WebSocketServerProtocol, data: dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç WebSocket –∫–ª–∏–µ–Ω—Ç–æ–≤"""
        message_type = data.get('type')
        
        if message_type == 'ping':
            await websocket.send(json.dumps({'type': 'pong'}))
        elif message_type == 'get_status':
            await websocket.send(json.dumps(await self.get_system_status()))
    
    async def handle_file_changes(self, request):
        """API: –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ñ–∞–π–ª–æ–≤"""
        api_requests_counter.labels(endpoint='file-changes', method='GET').inc()
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 –∏–∑–º–µ–Ω–µ–Ω–∏–π
        recent_changes = self.file_changes[-100:]
        self.file_changes = []  # –û—á–∏—â–∞–µ–º –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
        
        return web.json_response(recent_changes)
    
    async def handle_syntax_check(self, request):
        """API: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –∫–æ–¥–∞"""
        api_requests_counter.labels(endpoint='syntax-check', method='GET').inc()
        
        with check_duration_histogram.labels(check_type='syntax').time():
            errors = await self.run_syntax_check()
        
        syntax_errors_gauge.set(len(errors))
        
        return web.json_response({
            'errors': errors,
            'total': len(errors),
            'timestamp': datetime.now().isoformat()
        })
    
    async def handle_security_scan(self, request):
        """API: –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏"""
        api_requests_counter.labels(endpoint='security-scan', method='GET').inc()
        
        with check_duration_histogram.labels(check_type='security').time():
            vulnerabilities = await self.run_security_scan()
        
        security_issues_gauge.set(len(vulnerabilities))
        
        return web.json_response({
            'vulnerabilities': vulnerabilities,
            'total': len(vulnerabilities),
            'timestamp': datetime.now().isoformat()
        })
    
    async def handle_compliance_check(self, request):
        """API: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º"""
        standard = request.match_info['standard']
        api_requests_counter.labels(endpoint=f'compliance/{standard}', method='GET').inc()
        
        if standard not in self.compliance_standards:
            return web.json_response({'error': f'Unknown standard: {standard}'}, status=400)
        
        with check_duration_histogram.labels(check_type='compliance').time():
            result = await self.compliance_standards[standard]()
        
        compliance_score_gauge.labels(standard=standard).set(result['score'])
        
        return web.json_response(result)
    
    async def handle_integration_test(self, request):
        """API: –ó–∞–ø—É—Å–∫ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤"""
        api_requests_counter.labels(endpoint='integration-test', method='GET').inc()
        
        with check_duration_histogram.labels(check_type='integration').time():
            result = await self.run_integration_tests()
        
        return web.json_response(result)
    
    async def handle_start_watcher(self, request):
        """API: –ó–∞–ø—É—Å–∫ —Ñ–∞–π–ª–æ–≤–æ–≥–æ –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è"""
        api_requests_counter.labels(endpoint='start-watcher', method='POST').inc()
        
        data = await request.json()
        paths = data.get('paths', [])
        
        # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –ø—É—Ç–∏ –∫ –Ω–∞–±–ª—é–¥–µ–Ω–∏—é
        for path in paths:
            if Path(path).exists() and path not in self.watch_paths:
                self.watch_paths.append(path)
                if self.file_observer:
                    event_handler = FileChangeHandler(self)
                    self.file_observer.schedule(event_handler, path, recursive=True)
                    logger.info(f"Added watch path: {path}")
        
        watcher_id = hashlib.md5(str(time.time()).encode()).hexdigest()[:8]
        
        return web.json_response({
            'watcherId': watcher_id,
            'paths': self.watch_paths,
            'status': 'active'
        })
    
    async def handle_status(self, request):
        """API: –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–∏—Å—Ç–µ–º—ã"""
        api_requests_counter.labels(endpoint='status', method='GET').inc()
        
        status = await self.get_system_status()
        return web.json_response(status)
    
    async def handle_metrics(self, request):
        """API: Prometheus –º–µ—Ç—Ä–∏–∫–∏"""
        api_requests_counter.labels(endpoint='metrics', method='GET').inc()
        
        metrics = generate_latest()
        return web.Response(text=metrics.decode('utf-8'), content_type='text/plain')
    
    async def handle_agent_validate(self, request):
        """API: –í–∞–ª–∏–¥–∞—Ü–∏—è —á–µ—Ä–µ–∑ AI –∞–≥–µ–Ω—Ç–æ–≤"""
        api_requests_counter.labels(endpoint='agents/validate', method='POST').inc()
        
        data = await request.json()
        agents = data.get('agents', [])
        context = data.get('context', {})
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é —á–µ—Ä–µ–∑ –∞–≥–µ–Ω—Ç–æ–≤
        validation_score = await self.validate_with_agents(agents, context)
        
        return web.json_response({
            'score': validation_score,
            'agents': agents,
            'timestamp': datetime.now().isoformat()
        })
    
    async def handle_agent_process(self, request):
        """API: –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞ –∞–≥–µ–Ω—Ç–æ–º"""
        api_requests_counter.labels(endpoint='agents/process', method='POST').inc()
        
        data = await request.json()
        agent = data.get('agent')
        file_path = data.get('file')
        action = data.get('action')
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á—É –≤ –æ—á–µ—Ä–µ–¥—å –∞–≥–µ–Ω—Ç–∞
        task_id = await self.queue_agent_task(agent, file_path, action)
        
        return web.json_response({
            'taskId': task_id,
            'agent': agent,
            'status': 'queued'
        })
    
    async def run_syntax_check(self) -> List[Dict]:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞"""
        errors = []
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º Python —Ñ–∞–π–ª—ã
        python_files = Path('/Volumes/Z7S/development/GalaxyDevelopers/DevSystem').glob('**/*.py')
        
        for file_path in python_files:
            if 'venv' in str(file_path) or '__pycache__' in str(file_path):
                continue
                
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    code = f.read()
                    ast.parse(code)
            except SyntaxError as e:
                errors.append({
                    'file': str(file_path),
                    'line': e.lineno,
                    'message': str(e.msg),
                    'type': 'syntax_error'
                })
            except Exception as e:
                logger.error(f"Error checking {file_path}: {e}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º JavaScript —Ñ–∞–π–ª—ã —á–µ—Ä–µ–∑ subprocess
        js_files = Path('/Volumes/Z7S/development/GalaxyDevelopers/DevSystem').glob('**/*.js')
        
        for file_path in js_files:
            if 'node_modules' in str(file_path):
                continue
                
            try:
                result = subprocess.run(
                    ['node', '--check', str(file_path)],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if result.returncode != 0:
                    errors.append({
                        'file': str(file_path),
                        'message': result.stderr,
                        'type': 'syntax_error'
                    })
            except Exception as e:
                logger.error(f"Error checking JS {file_path}: {e}")
        
        return errors
    
    async def run_security_scan(self) -> List[Dict]:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏"""
        vulnerabilities = []
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º bandit –¥–ª—è Python —Ñ–∞–π–ª–æ–≤
        from bandit.core import manager
        
        # –°–∫–∞–Ω–∏—Ä—É–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
        target_dir = '/Volumes/Z7S/development/GalaxyDevelopers/DevSystem'
        
        try:
            b_mgr = manager.BanditManager()
            
            # –°–æ–±–∏—Ä–∞–µ–º Python —Ñ–∞–π–ª—ã
            python_files = []
            for file_path in Path(target_dir).glob('**/*.py'):
                if 'venv' not in str(file_path) and '__pycache__' not in str(file_path):
                    python_files.append(str(file_path))
            
            if python_files:
                b_mgr.discover_files(python_files)
                b_mgr.run_tests()
                
                for issue in b_mgr.get_issue_list():
                    vulnerabilities.append({
                        'file': issue.fname,
                        'line': issue.lineno,
                        'severity': issue.severity,
                        'confidence': issue.confidence,
                        'test': issue.test,
                        'message': issue.text
                    })
        except Exception as e:
            logger.error(f"Security scan error: {e}")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ hardcoded credentials
        patterns = [
            (r'password\s*=\s*["\'][^"\']+["\']', 'Hardcoded password'),
            (r'api_key\s*=\s*["\'][^"\']+["\']', 'Hardcoded API key'),
            (r'secret\s*=\s*["\'][^"\']+["\']', 'Hardcoded secret'),
        ]
        
        import re
        for file_path in Path(target_dir).glob('**/*.py'):
            if 'venv' in str(file_path):
                continue
                
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    for pattern, message in patterns:
                        matches = re.finditer(pattern, content, re.IGNORECASE)
                        for match in matches:
                            line_num = content[:match.start()].count('\n') + 1
                            vulnerabilities.append({
                                'file': str(file_path),
                                'line': line_num,
                                'severity': 'HIGH',
                                'message': message
                            })
            except Exception as e:
                logger.error(f"Error scanning {file_path}: {e}")
        
        return vulnerabilities
    
    async def check_iso27001_compliance(self) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è ISO 27001"""
        checks = {
            'access_control': self.check_access_control(),
            'encryption': self.check_encryption(),
            'logging': self.check_logging(),
            'backup': self.check_backup(),
            'incident_response': self.check_incident_response()
        }
        
        passed = sum(1 for v in checks.values() if v)
        total = len(checks)
        score = (passed / total) * 100
        
        return {
            'standard': 'ISO27001',
            'score': score,
            'compliant': score >= 80,
            'checks': checks,
            'timestamp': datetime.now().isoformat()
        }
    
    async def check_itil4_compliance(self) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è ITIL 4"""
        checks = {
            'service_catalog': self.check_service_catalog(),
            'change_management': self.check_change_management(),
            'incident_management': self.check_incident_management(),
            'problem_management': self.check_problem_management(),
            'configuration_management': self.check_configuration_management()
        }
        
        passed = sum(1 for v in checks.values() if v)
        total = len(checks)
        score = (passed / total) * 100
        
        return {
            'standard': 'ITIL4',
            'score': score,
            'compliant': score >= 75,
            'checks': checks,
            'timestamp': datetime.now().isoformat()
        }
    
    async def check_cobit_compliance(self) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è COBIT"""
        checks = {
            'governance': self.check_governance(),
            'risk_management': await self.check_risk_management_async(),
            'performance_monitoring': self.check_performance_monitoring(),
            'resource_optimization': self.check_resource_optimization()
        }
        
        passed = sum(1 for v in checks.values() if v)
        total = len(checks)
        score = (passed / total) * 100
        
        return {
            'standard': 'COBIT',
            'score': score,
            'compliant': score >= 70,
            'checks': checks,
            'timestamp': datetime.now().isoformat()
        }
    
    def check_access_control(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª—è –¥–æ—Å—Ç—É–ø–∞"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–æ–≤ —Å –ø—Ä–∞–≤–∞–º–∏ –¥–æ—Å—Ç—É–ø–∞
        auth_files = [
            '/Volumes/Z7S/development/GalaxyDevelopers/DevSystem/.htaccess',
            '/Volumes/Z7S/development/GalaxyDevelopers/DevSystem/auth.json'
        ]
        return any(Path(f).exists() for f in auth_files)
    
    def check_encryption(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ HTTPS –∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
        config_path = Path('/Volumes/Z7S/development/GalaxyDevelopers/DevSystem/config.json')
        if config_path.exists():
            with open(config_path) as f:
                config = json.load(f)
                return config.get('encryption', {}).get('enabled', False)
        return False
    
    def check_logging(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è"""
        log_dir = Path('/Volumes/Z7S/development/GalaxyDevelopers/DevSystem/logs')
        return log_dir.exists() and any(log_dir.iterdir())
    
    def check_backup(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        backup_dir = Path('/Volumes/Z7S/development/GalaxyDevelopers/DevSystem/backups')
        return backup_dir.exists()
    
    def check_incident_response(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –∏–Ω—Ü–∏–¥–µ–Ω—Ç—ã"""
        incident_file = Path('/Volumes/Z7S/development/GalaxyDevelopers/DevSystem/docs/incident_response.md')
        return incident_file.exists()
    
    def check_service_catalog(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞ —Å–µ—Ä–≤–∏—Å–æ–≤"""
        return Path('/Volumes/Z7S/development/ALBERT_TOOLS_PLACE/DocumentsSystem').exists()
    
    def check_change_management(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏"""
        git_dir = Path('/Volumes/Z7S/development/GalaxyDevelopers/.git')
        return git_dir.exists()
    
    def check_incident_management(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞–º–∏"""
        return self.memory_db_path.exists()
    
    def check_problem_management(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º–∞–º–∏"""
        return True  # –°—á–∏—Ç–∞–µ–º —á—Ç–æ —Å–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —ç—Ç–æ –∏ –µ—Å—Ç—å problem management
    
    def check_configuration_management(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è–º–∏"""
        config_files = [
            '/Volumes/Z7S/development/GalaxyDevelopers/DevSystem/config.json',
            '/Volumes/Z7S/development/GalaxyDevelopers/DevSystem/package.json'
        ]
        return any(Path(f).exists() for f in config_files)
    
    def check_governance(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è"""
        return Path('/Volumes/Z7S/development/GalaxyDevelopers/DevSystem/README.md').exists()
    
    async def check_risk_management_async(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∏—Å–∫–∞–º–∏"""
        vulnerabilities = await self.run_security_scan()
        return len(vulnerabilities) == 0
    
    def check_risk_management(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∏—Å–∫–∞–º–∏ (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
        return False  # –ö–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
    
    def check_performance_monitoring(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
        return True  # –≠—Ç–∞ —Å–∏—Å—Ç–µ–º–∞ –∏ –µ—Å—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
    
    def check_resource_optimization(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Ä–µ—Å—É—Ä—Å–æ–≤"""
        return True  # –°—á–∏—Ç–∞–µ–º —á—Ç–æ executor —Å –ø—É–ª–æ–º –ø–æ—Ç–æ–∫–æ–≤ —ç—Ç–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
    
    async def run_integration_tests(self) -> Dict:
        """–ó–∞–ø—É—Å–∫ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤"""
        tests = []
        
        # –¢–µ—Å—Ç 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        ws_test = {
            'name': 'WebSocket Connection',
            'passed': len(self.websocket_clients) >= 0,
            'message': f'{len(self.websocket_clients)} active connections'
        }
        tests.append(ws_test)
        
        # –¢–µ—Å—Ç 2: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∞–π–ª–æ–≤–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
        file_test = {
            'name': 'File Monitoring',
            'passed': self.file_observer and self.file_observer.is_alive(),
            'message': f'Watching {len(self.watch_paths)} paths'
        }
        tests.append(file_test)
        
        # –¢–µ—Å—Ç 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø–∞–º—è—Ç–∏
        db_test = {
            'name': 'Memory Database',
            'passed': self.memory_db_path.exists(),
            'message': 'Database accessible'
        }
        tests.append(db_test)
        
        # –¢–µ—Å—Ç 4: –ü—Ä–æ–≤–µ—Ä–∫–∞ API endpoints
        api_test = {
            'name': 'API Endpoints',
            'passed': True,
            'message': 'All endpoints registered'
        }
        tests.append(api_test)
        
        passed = sum(1 for t in tests if t['passed'])
        failed = len(tests) - passed
        
        return {
            'tests': tests,
            'passed': passed,
            'failed': failed,
            'total': len(tests),
            'success_rate': (passed / len(tests)) * 100,
            'timestamp': datetime.now().isoformat()
        }
    
    async def validate_with_agents(self, agents: List[str], context: Dict) -> float:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è —á–µ—Ä–µ–∑ AI –∞–≥–µ–Ω—Ç–æ–≤"""
        try:
            # –ó–¥–µ—Å—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –∞–≥–µ–Ω—Ç–∞–º–∏
            # –ü–æ–∫–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ü–µ–Ω–∫—É –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
            
            base_score = 85.0
            
            # –î–æ–±–∞–≤–ª—è–µ–º –±–∞–ª–ª—ã –∑–∞ —Ö–æ—Ä–æ—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏
            if self.file_observer and self.file_observer.is_alive():
                base_score += 5
            
            if len(self.websocket_clients) > 0:
                base_score += 5
            
            # –í—ã—á–∏—Ç–∞–µ–º –∑–∞ –ø—Ä–æ–±–ª–µ–º—ã
            errors = await self.run_syntax_check()
            if errors:
                base_score -= min(len(errors), 10)
            
            vulnerabilities = await self.run_security_scan()
            if vulnerabilities:
                base_score -= min(len(vulnerabilities) * 2, 15)
            
            return max(min(base_score, 100), 0)
        except Exception as e:
            logger.error(f"Error in validate_with_agents: {e}")
            return 75.0  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤—ã–π score –ø—Ä–∏ –æ—à–∏–±–∫–µ
    
    async def queue_agent_task(self, agent: str, file_path: str, action: str) -> str:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –≤ –æ—á–µ—Ä–µ–¥—å –∞–≥–µ–Ω—Ç–∞"""
        task_id = hashlib.md5(f"{agent}{file_path}{time.time()}".encode()).hexdigest()[:12]
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∞–≥–µ–Ω—Ç–∞
        self.agent_statuses[agent] = {
            'status': 'processing',
            'current_task': f"{action} {file_path}",
            'task_id': task_id,
            'started_at': datetime.now().isoformat()
        }
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ WebSocket
        await self.broadcast_to_websockets({
            'type': 'agent_status',
            'agent': agent,
            'status': 'active'
        })
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ø–∞–º—è—Ç—å
        if self.memory_db_path.exists():
            conn = sqlite3.connect(self.memory_db_path)
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO knowledge (key, value, importance, last_updated, source)
                VALUES (?, ?, ?, ?, ?)
                ON CONFLICT(key) DO UPDATE SET value=excluded.value, last_updated=excluded.last_updated
            """, (
                f"agent_task_{task_id}",
                json.dumps({'agent': agent, 'file': file_path, 'action': action}),
                8,
                time.time(),
                'monitoring_system'
            ))
            conn.commit()
            conn.close()
        
        logger.info(f"Queued task {task_id} for {agent}")
        
        return task_id
    
    async def get_system_status(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª–Ω–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞ —Å–∏—Å—Ç–µ–º—ã"""
        return {
            'type': 'system_status',
            'websocket_clients': len(self.websocket_clients),
            'file_observer_active': self.file_observer and self.file_observer.is_alive(),
            'watched_paths': self.watch_paths,
            'recent_changes': len(self.file_changes),
            'agent_statuses': self.agent_statuses,
            'timestamp': datetime.now().isoformat()
        }
    
    async def run_periodic_checks(self):
        """–ó–∞–ø—É—Å–∫ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫"""
        while True:
            try:
                # –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
                await asyncio.sleep(30)
                
                # –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫–∏
                syntax_errors = await self.run_syntax_check()
                security_issues = await self.run_security_scan()
                
                # –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏
                syntax_errors_gauge.set(len(syntax_errors))
                security_issues_gauge.set(len(security_issues))
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —á–µ—Ä–µ–∑ WebSocket
                status = await self.get_system_status()
                status['syntax_errors'] = len(syntax_errors)
                status['security_issues'] = len(security_issues)
                
                await self.broadcast_to_websockets(status)
                
                logger.info(f"Periodic check: {len(syntax_errors)} syntax errors, {len(security_issues)} security issues")
                
            except Exception as e:
                logger.error(f"Error in periodic checks: {e}")
    
    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞"""
        if self.file_observer:
            self.file_observer.stop()
            self.file_observer.join()
        
        self.executor.shutdown(wait=True)
        logger.info("üõë Monitoring server stopped")


async def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    server = MonitoringServer()
    
    try:
        await server.start()
    except KeyboardInterrupt:
        logger.info("Shutting down...")
        server.stop()
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        server.stop()


if __name__ == '__main__':
    print("""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë     GALAXY MONITORING SERVER v2.0      ‚ïë
    ‚ïë     Real-time System Monitoring        ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    asyncio.run(main())